# 前端性能优化


  暂且不论系统后端的性能瓶颈，让我们来了解下前端能做到哪些新能优化

##  一、页面级的优化
### 1.减少http的请求数
<br/>一个完整的请求需要经过DNS寻址、与服务器建立连接、发送数据、等待服务器相应、接收并处理返回的数据 这样的一个'漫长'的过程,
<br/>并且浏览器对同一服务器的并发连接个数是有限制的(详情见表1-1),合并请求，减少DNS查找等是非常有效的方法

| Browser                 | HTTP/1.1 | HTTP/1.0 |
| ----------------------- | -------- | -------: |
| IE 11                   | 6        | 6        |
| IE 10                   | 6        | 6        |
| IE 9                    | 10       | 10       |
| IE 8                    | 6        | 6        |
| IE 6,7                  | 2        | 4        |
| Firefox                 | 6        | 6        |
| Safari 3,4              | 4        | 4        |
| Chrome 4+               | 6        | 6        |
| Opera   9.63,10.00alpha | 4        | 4        |
| Opera 10.51+            | 8        | 7        |
##### 表1-1
<br/>

 1）从页面设计来说，尽量设计简单的界面就能满足需求的话，何乐为不为呢

 2）资源的合并与压缩
 <br/>在浏览器中请求一个10k的文件和2个5k的文件花费的总时间肯定是一个10k的文件用时要少，如果不进行合并有的复杂的页面有上百个资源需要请求
 
 <br/>①我们可以尽可能的将外部的脚本、样式进行合并。
 <br/>②生成精灵图等减少请求，我们可以将小的图片直接转成base64位编码直接存在css样式文件中，这是可以在构建项目的时候在gulp或者webpack配置中进行配置的
<br/>③js和css进行代码压缩，减少文件大小。

<br/>④CDN(内容分发网络) 将静态资源和动态资源进行分类，放在多个服务器上，如果能配合nginx负载均衡的话就更好了，
<br/>虽然我们浏览器对单个服务器有并发限制，但是我们如果是多个服务器的话，那么并发数量就提升了

3）图片懒加载(Lazy Load Images)
<br/>虽然这样做不会直接改变请求数，但是可以做到在打开页面的时候做到在页面刚加载的时候只加载第一屏，当用户继续浏览剩余的内容时候在进行加载，做到按需加载


### 2. CSS和JS文件引用位置
1）上面我们说到浏览器可以并发请求资源的，这使得资源加载更快，但是我们在加载外部资源的时候会阻塞其他资源。
<br/>所以我们可以将外部脚本资源放在页面body的最后一行进行script标签引入，或者在script标签中加async(HTML5.0),defe(HTML4.0)，实现异步加载。

2）Lazy Load Javascript/或者称之为按需加载
<br/>在script中增加async属性(缺点是不能控制加载的顺序)
<br/>遵循amd或者cmd规范 使用requirejs或者seajs
<br/>...
<br/>一般情况我们把我们js文件放在body最后一行进行引入，这样做的好处是不会阻塞界面渲染和其他资源的引入

3）CSS推荐放到head标签内，因为浏览器是至上而下进行加载(除去异步等)，如果不在head标签内的话，我们页面已经渲染部分节点，
<br/>但是却还没有样式，这样对于用户来说交互不美好。



##  二、代码级的优化

### 1. 减少DOM操作
1）DOM操作应该是脚本执行中最消耗性能一类操作了。

2）Reflow & Repaint
<br/> 我们知道浏览器在渲染界面的时候，是根据DOM树和CSS树组成了渲染树，然后渲染引擎根据渲染数据进行渲染。
<br/>但是在改变元素大小，文本内容，新增或者删除节点的时候，会进行DOM树和渲染树的重新计算，这使得我们需要花费更多时间在DOM上，如果我们的操作很频繁的话，特别影响浏览器的性能
<br/>在style样式改变的时候也是进行重排的，所以我们建议能在js中切换类的就不要用js的style设置样式
<br/>假设我们在没有vue和react的情况下，我们可以把增加、修改、删除DOM元素的操作进行有效的合并，等到最后的时候操作DOM，减少和DOM交互的次数，也是可以提升性能的。
<br/>vue和react有虚拟DOM概念，我们操作虚拟DOM，框架diff算法可以高效的计算出我们需要改动的dom元素，这样可以有效的避免重排和重绘

<br/>在改变元素的visibility、outline、背景色、边框颜色等会引入重汇，当然重汇效率比重排高很多

3）慎用 with、避免使用 eval和 Function、减少作用域链查找、字符串拼接、数据访问等

4）HTML 尽量减少html元素的嵌套、善用语义化标签等

5）image 
<br/>&nbsp;&nbsp;1）优化图片大小、通过CSS Sprites优化图片、不要在HTML中使用缩放图片、favicon.ico要小而且可缓存
<br/>&nbsp;&nbsp;2）图片的格式png、jpg、gif、svg等选择
<br/>&nbsp;&nbsp;&nbsp;&nbsp;①png PNG-8具有更小的文件体积,并且可以设置透明度，这是gif做不到的
<br/>&nbsp;&nbsp;&nbsp;&nbsp;②jpg jpg不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大
<br/>&nbsp;&nbsp;&nbsp;&nbsp;③gif GIF是无损的，采用GIF格式保存图片不会降低图片质量，但GIF格式仅支持8bit的索引色，即在整个图片中，只能存在256种不同的颜色,
<br/>&nbsp;&nbsp;&nbsp;&nbsp;GIF格式适用于对色彩要求不高同时需要文件体积较小的场景，比如企业Logo、线框类
<br/>&nbsp;&nbsp;&nbsp;&nbsp;④svg SVG图片在放大时，不会失真，所以它非常适合用来绘制企业Logo、Icon


##  三、服务端渲染


